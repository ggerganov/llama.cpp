root ::= grammarSpec
grammarSpec ::= grammarDecl prequelConstruct* rules modeSpec* EOF
grammarDecl ::= grammarType identifier SEMI
grammarType ::= (LEXER GRAMMAR) | (PARSER GRAMMAR) | GRAMMAR
prequelConstruct ::= optionsSpec | delegateGrammars | tokensSpec | channelsSpec | action_
optionsSpec ::= OPTIONS (option SEMI)* RBRACE
option ::= identifier ASSIGN optionValue
optionValue ::= (identifier (DOT identifier)*) | STRING_LITERAL | actionBlock | INT
delegateGrammars ::= IMPORT delegateGrammar (COMMA delegateGrammar)* SEMI
delegateGrammar ::= (identifier ASSIGN identifier) | identifier
tokensSpec ::= TOKENS idList? RBRACE
channelsSpec ::= CHANNELS idList? RBRACE
idList ::= identifier (COMMA identifier)* COMMA?
action_ ::= AT (actionScopeName COLONCOLON)? identifier actionBlock
actionScopeName ::= identifier | LEXER | PARSER
actionBlock ::= BEGIN_ACTION ACTION_CONTENT* END_ACTION
argActionBlock ::= BEGIN_ARGUMENT ARGUMENT_CONTENT* END_ARGUMENT
modeSpec ::= MODE identifier SEMI lexerRuleSpec*
rules ::= ruleSpec*
ruleSpec ::= parserRuleSpec | lexerRuleSpec
parserRuleSpec ::= ruleModifiers? RULE_REF argActionBlock? ruleReturns? throwsSpec? localsSpec? rulePrequel* COLON ruleBlock SEMI exceptionGroup
exceptionGroup ::= exceptionHandler* finallyClause?
exceptionHandler ::= CATCH argActionBlock actionBlock
finallyClause ::= FINALLY actionBlock
rulePrequel ::= optionsSpec | ruleAction
ruleReturns ::= RETURNS argActionBlock
throwsSpec ::= THROWS identifier (COMMA identifier)*
localsSpec ::= LOCALS argActionBlock
ruleAction ::= AT identifier actionBlock
ruleModifiers ::= ruleModifier+
ruleModifier ::= PUBLIC | PRIVATE | PROTECTED | FRAGMENT
ruleBlock ::= ruleAltList
ruleAltList ::= labeledAlt (OR labeledAlt)*
labeledAlt ::= alternative (POUND identifier)?
lexerRuleSpec ::= FRAGMENT? TOKEN_REF optionsSpec? COLON lexerRuleBlock SEMI
lexerRuleBlock ::= lexerAltList
lexerAltList ::= lexerAlt (OR lexerAlt)*
lexerAlt ::= (lexerElements lexerCommands?) | ()
lexerElements ::= lexerElement+ | ()
lexerElement ::= (lexerAtom ebnfSuffix?) | (lexerBlock ebnfSuffix?) | (actionBlock QUESTION?)
lexerBlock ::= LPAREN lexerAltList RPAREN
lexerCommands ::= RARROW lexerCommand (COMMA lexerCommand)*
lexerCommand ::= (lexerCommandName LPAREN lexerCommandExpr RPAREN) | lexerCommandName
lexerCommandName ::= identifier | MODE
lexerCommandExpr ::= identifier | INT
altList ::= alternative (OR alternative)*
alternative ::= (elementOptions? element+) | ()
element ::= (labeledElement (ebnfSuffix | ())) | (atom (ebnfSuffix | ())) | ebnf | (actionBlock (QUESTION predicateOptions?)?)
predicateOptions ::= LT predicateOption (COMMA predicateOption)* GT
predicateOption ::= elementOption | (identifier ASSIGN actionBlock)
labeledElement ::= identifier (ASSIGN | PLUS_ASSIGN) (atom | block)
ebnf ::= block blockSuffix?
blockSuffix ::= ebnfSuffix
ebnfSuffix ::= (QUESTION QUESTION?) | (STAR QUESTION?) | (PLUS QUESTION?)
lexerAtom ::= characterRange | terminalDef | notSet | LEXER_CHAR_SET | (DOT elementOptions?)
atom ::= terminalDef | ruleref | notSet | (DOT elementOptions?)
notSet ::= (NOT setElement) | (NOT blockSet)
blockSet ::= LPAREN setElement (OR setElement)* RPAREN
setElement ::= (TOKEN_REF elementOptions?) | (STRING_LITERAL elementOptions?) | characterRange | LEXER_CHAR_SET
block ::= LPAREN (optionsSpec? ruleAction* COLON)? altList RPAREN
ruleref ::= RULE_REF argActionBlock? elementOptions?
characterRange ::= STRING_LITERAL RANGE STRING_LITERAL
terminalDef ::= (TOKEN_REF elementOptions?) | (STRING_LITERAL elementOptions?)
elementOptions ::= LT elementOption (COMMA elementOption)* GT
elementOption ::= identifier | (identifier ASSIGN (identifier | STRING_LITERAL))
identifier ::= RULE_REF | TOKEN_REF
